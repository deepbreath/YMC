### 关于锁  
数据库锁用来干嘛的?  
如果没有数据库锁会怎么样?  

锁的相关知识又跟存储引擎，索引，事务的隔离级别都是关联的  

锁 是配合索引和事物的隔离级别来的  

行锁需要通过索引, 如果没有索引 表会使用隐藏的 聚簇索引作为行锁..  


### 什么是乐观锁和悲观锁?  
* 乐观锁:  
乐观锁是一种思想, 具体实现是,表中有一个 版本号或者时间戳 字段,第一次读的时候,获取版本字段信息.   
处理完成业务开始更新的时候,查看该字段是否与原来一致,    
如果版本号或者时间戳更新了 则拒绝写入,之所以称之为乐观,  
因为这个操作并不是在数据库层面加锁,等到更新的时候在判断是否可以更新  
例如:  
张三 select * from table  -----> 查询出记录,并包含版本信息 version 字段  
李四 select * from table  -----> 也会查询出记录, 也包含了 version 字段  
李四 最当前数据做了修改, update table set name="w",version=version+1 where id=#{id} and version=#{version} 同时更新 version 字段  
当前数据库存储值 name:w  version:2  
张三同时也对这个这条数据进行了更新操作 update table set name="w",version=version+1 where id=#{id} and version=#{version} 由于数据库中   
不存在 version =1 的数据 则更新失败  

* 悲观锁:  
    悲观锁是在数据库层面加锁,都会阻塞等待锁  
    在 select 语句后面加入 for update 相当于加入排它锁(写锁) 加了写锁以后,  
    其他事务就无法对其进行修改了,需求等待事务完成后才可以修改  

为什么需要这两个锁?   
因为在数据库的四个事务中 三个事务 会产生读写冲突问题,  
所以需要 使用 Serializable 隔离级别, 或者使用乐观锁悲观锁来解决这个问题  

数据库隔离级别  
读未提交 (Read uncommitted)  
  会出现脏读,不可重复读,幻读  
读已提交 (Read committed)  
  出现不可重复读,幻读  
重复读 (Repeatable read)  
  会出现幻读(但在Mysql实现的Repeatable read配合gap锁不会出现幻读！)  
序列化 (Serializable)  
  串行避免以上所有问题  

### 行级锁表级锁  
什么是行级锁?  
开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高  
只针对表中行数据进行加锁,这样子其他进程还可以对同一张表别的数据进行修改    

什么是表级锁?  
开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
对整张表进行加锁, 在用户对这张表读写前,必须先获得写锁, 这时候就会阻塞别的用户对这张表的读写操作. 
只有没有写锁的时候,其他用户才能获得到读锁,    
读锁之间是不会相互阻塞的.  

两个锁之间的平衡:  
 1. 锁定的数量越少,锁竞争发生的频率就越小,系统并发的程度越高.  
 2. 锁的颗粒度越小, 系统资源消耗越大.  
在 InnoDB 数据库引擎中 行锁是通过索引上的索引项来加锁实现的, 如果没有索引 InnoDB 将通过隐式聚簇索引来对记录加锁  
基于
 
### 读写锁
什么是读写锁?  
独享锁 (Exclusive),简写 X 锁,又成为写锁,排他锁,使用方式 SELECT.....FOR UPDATE;
共享锁 (Shared), 简写 S 锁,称之为读锁, 使用方式:SELECT.....LOCK IN SHARE MODE;

排他锁-写锁--X锁
共享锁-读锁--S锁

InnoDB 下的行锁, 间隙锁, next-key 锁都是属于独享锁

### 意向锁  
什么是意向锁?  
(https://juejin.cn/post/6844903666332368909#heading-4)  
是InnoDB一种多粒度锁(multiple granularity locking) 它允许 行级锁 和 表级锁共存.意向锁 是其中的一种 表锁 ? 是表锁?  

##### 意向锁 是一种不与行级别锁冲突的表锁  
意向锁是数据引擎自己维护的,用户无法手动操作:

    1. 当时事务要获得某一行的 S 锁时候,必须先获得表的 IS(intention Locks 意向共享锁) 锁.  
    select column from table ... LOCK IN SHARE MODE;  
    2. 当事务要获得某一行的 X 锁时候, 必须先获得该表的 IX (intention Locks 意向排他锁) 锁.
    select column from table .... for update;  

#### 意向锁不会与行级的共享/排他锁互斥  
用来解决什么问题?  
1. InnoDB 支持多颗粒锁,特定场景下可以与表级锁共存  
2. 意向锁之间互不排斥,但除了 IS 与 S 兼容外,意向锁会与共享锁/排他锁互斥.  
3. IX IS 是表级锁,不会和 行级别 X S锁发生冲突.只会和 表级别 S,X发生冲突  
4. 意向锁在保证并发性的前提下,实现了行锁和表锁共存,且满足事务的隔离性  

加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。  
那么，意向锁的作用就是“表明”加锁的意图  

为什么会有意向锁?  
这两中类型的锁共存的问题考虑这个例子：  

     事务A锁住了表中的一行，让这一行只能读，不能写。  
     之后，事务 B 申请整个表的写锁。  
     如果 事务 B 申请成功，那么理论上它就能修改表中的任意一行，  
     这与 A 持有的行锁是冲突的。  

数据库需要避免这种冲突，就是说要让 B 的申请被阻塞，直到 A 释放了行锁。   
数据库要怎么判断这个冲突呢？   

step1：判断表是否已被其他事务用表锁锁表    
step2：判断表中的每一行是否已被行锁锁住。    
注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。   
于是就有了意向锁。   

### 间隙锁 GAP
间隙锁，锁定一个范围，但不包括记录本身。  
GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。  

用于范围条件检索数据  
当我们用范围条件检索数据而不是相等条件检索数据，    
并请求共享或排他锁时，  
InnoDB会给符合范围条件的已有数据记录的索引项加锁；  
对于键值在条件范围内但并不存在的记录，  
叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，  
这种锁机制就是所谓的间隙锁。  

可以理解成对一定条件范围内的数据加锁,    
也会对键值范围内但不存在的记录加锁  

使用间隙锁能解决什么问题?  
在重复读的隔离级别下 添加间隙锁有效防止幻读    
满足恢复和复制的需要    
MySql的恢复机制:在一个事务未提交前,其他并发事务不能插入满足其锁定条件的任何记录,防止幻读  

####Record Lock：单个行记录上的锁。  

### Next-key锁  
什么是 Next-key 锁?  
数据库InnoDB存储引擎实现的一种锁  
既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录    
next-key锁的本质就是一个正经记录锁和一个gap锁的合体，它既能保护该条记录，  
又能阻止别的事务将新记录插入被保护记录前边的间隙    
MVCC 不能解决幻读问题，Next-Key 锁就是为了解决幻读问题。  
在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key 锁 可以解决幻读问题。  
Next-Key Locks; 又称为 LOCK_ORDINARY, 我们简称 Next-key 锁     

### 死锁  
回滚会帮助解决一些死锁问题  
通过一下方式减少死锁:  
1. 以固定顺序访问表和行,  
2. 大事务拆小  
3. 降低隔离级别  
4. 为表添加合理的索引  
5. 在同一个事务中,尽可能做到一次锁定所需要的资源,减少死锁的频率    

### MVCC
什么是 MVCC (Multi-Version Concurrency Control)?  
可以理解成行级别锁的一种变种(升级版)  

事务的隔离级别是通过锁的机制来实现的. 只不过隐藏了细节  
表锁中读写是阻塞的.基于提升性能考虑,  
MVCC一般读写不阻塞(MVCC很多情况下是避免了加锁的情况)      

MVCC 实现读写不阻塞是因为:  
多版本并发控制->通过一定机制生成一个数据请求时间点一致的数据快照(Snapshot),  
并用快照来提供一定级别(语句级别或事务级别)    
的一致性读取.从用户的角度看,好像是数据可以提供同一数据多个版本.  

语句级别:  
    针对与 Read committed 级别  
事务级别:  
    针对 Repeatable committed 级别    

多版本并发控制(Multi-Version Concurrency Control,MVCC) 是 InnoDB存储引擎实现隔离级别的一种具体方式,   
用于实现 提交读 和 可重复读 这两种事务隔离级别.  
因为 读未提交隔离级别总是读取最新的数据,对事务要求很低,所以无需MVCC,   
而串行化 隔离级别对所有行加锁,单纯使用MVCC无法实现  

###MVCC的主要思想:  
保存数据在某个时间点的快照。  
写操作（DELETE、INSERT、UPDATE）更新最新的版本快照，    
而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。   
脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。  
在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。    
当然一个事务可以读取自身未提交的快照，这不算是脏读




