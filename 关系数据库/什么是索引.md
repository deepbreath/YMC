Mysql索引  
索引是在存储引擎实现的,而不是在服务层实现的,所以不同的存储引擎具有不同的索引类型和实现  

什么是索引?  
索引是对数据库表中一或多个列值进行排序的结构,帮助数据库提高查询效率的数据结构  

如果没有索引会产生什么问题呢?
随着数据量变大

### 索引的优缺点:  
优点:  
 索引大大减少服务器需要扫描的数据量,从而加快检索速度  
   为什么可以提高查询速度呢?  
    采用 B Tree 和  B+ Tree 等数据结构的原因

   提高查询速度的机制是什么?
 
 支持行级锁数据库,如 InnoDB 会在访问行的时候加锁.使用索引可以减少访问的行数,从而减少锁的竞争,提高并发
 索引可以帮助服务器避免排序和临时表
 唯一索引可以确保每一行数据的唯一性,通过使用索引,可以在查询的过程中使用优化隐藏器,提高系统的性能
 什么是隐藏器? 索引如何确保么一行的数据唯一性?
 将随机 IO 变成顺序IO  

缺点:  
 创建索引和维护索引会耗费时间,这随着数据量的增加而增加  
 索引会占用额外的物理空间,除了数据表占数据空间外,每个索引还要占一定的物理空间,建立组合索引需要的空间更大(为什么会占用那么大?)  
 写操作(insert/update/DELETE) 时需要更新索引,导致数据库写操作性能降低  为什么降低? 加锁了
 为什么说索引会降低插入、删除、修改等维护任务的速度?  

### 索引的适用场景
经常进行 SELECT 操作  
表的数据量为中大类型,为什么特大不行?  
列名经常出现 Where 或者链接 JOIN 条件中  

### 索引不适合的场景
频繁写操作 随着数据量增大 更新索引空间的效率越低
非常小的表 数据量小的时候全表扫描更有效果
对于特大型表,随着数据量的巨大创建和使用索引的代价随之增长(需要考虑分区技术 或者 Nosql)

### 索引有哪些类型?
  从逻辑上划分(即一般创建表时设置的索引类型)  
     唯一索引(UNIQUE): 索引列的值必须唯一, 但允许有空值.如果是组合索引,则列值的组合必须唯一
     主键索引(PRIMARY): 一种特殊的唯一索引,一个表只能有一个主键,不允许有空值.一般实在建表的时候同时创建主键索引
     普通索引(INDEX): 最基本的索引,没有任何限制
     组合索引: 多个字段上创建的索引,只有在查询条件中使用了创建索引时的第一个字段,索引才会被使用.使用组合索引时遵循最左前缀集合
  从物理存储上划分  
     聚簇索引(Clustered):表中各行的物理顺序与键值的逻辑(索引)顺序相同,每个表只能有一个  
     什么是聚簇索引?
     非聚簇索引(Non-clustered):非聚簇索引指定表的逻辑顺序,也可以视为二级索引. 数据存储在一个位置,索引存储在另外一个位置,
     索引中包含指向数据存储位置的指针.可以有多个,但是小于 249 个
     为什么小于 249 个?
     现实场景中是什么样子?
     什么是非聚簇索引?   

### 聚簇索引和非聚簇索引有什么区别?  
不清楚有什么区别, 一个是放在单表呢? 且与表中行书讯 键值顺序相同,每个表只能有一个
非聚簇指的是表的逻辑顺序,数据存储在一个位置, 索引存储在另外一个位置. 索引中包含数据存储位置的指针

###索引有哪些常用数据结构 ?
 B 树和 B+ 树  

#### 什么是 B 树?(需要深入暂时记下)
一颗 M 阶的 B-Tree 满足以下条件:
每个节点至少有 M 个孩子;
除根节点和叶节点外,其它每个节点至少M/2个孩子
根节点至少有两个孩子(除非该树仅包含一个结点);
所有叶结点在同一层,叶结点不包含任何关键信息;
有K个关键字的非叶结点恰好包含K+1个孩子
对于任意结点,其内部的关键字 Key 是升序排列的.每个结点中都包含了 data.

对于每个结点,主要包含一个关键字数组 key[], 一个指针数组指向儿子 son[].
在 B-Tree 内,查找数组流程是:  
 1.使用顺序查找(数组长短比较时)或折半查找方法查找 Key[] 数组,若找到关键字 K,则返回该结点的地址及 K 在 Key[] 中的位置;
2.否则,可确定 K 在某个 Key[i] 和 Key[i+1] 之间,则从 Son[i] 所指的子节点继续查找,直到在某结点中查找成功;
3.或直至找到叶结点中的查找仍然不成功时,查找过程失败

#### 什么是 B+ 树?(需要深入)
B+Tree 是 B-Tree 的变种:
每个节点的指针上限 2d 而不是 2d+1 (d 为节点的出度)
非叶子节点不存储 data,只存储 Key; 叶子节点不存储指针.

由于并不是所有节点都具有相同的域, 因此 B+Tree 中叶节点和内节点一般大小不同(??). 这点与 B-Tree 不同,虽然 B-Tree 中不同节点存放的 Key 和指针可能数量不一致,
但是每个节点的域和上限是一致的,所以现实中 B-Tree 往往对每个节点申请同等大小的空间

#### B 树和 B+树对比
B-Tree 文件磁盘系统
B+Tree MySql 索引
B+Tree 更适合外部存储(一般指磁盘存储), 由于内节点(非叶子节点)不存储data,所以一个节点可以存储更多内节点  

为什么B+Tree 更适合存储 因为单个节点索引范围更大更精确? 为什么会更精确?
每个节点能索引的范围更大更精确. 也就是说 使用 B+ 树单次磁盘IO 的信息量相比较 B 树更大,IO 效率更高

Mysql 是关系型数据库,经常按照区间访问某个索引列, B+Tree 树的叶子节点间按顺序建立了链指针,加强了区间访问性,所以 B+树对索引列上的区间范围查找友好.
而 B 树每个节点的Key 和 data 在一起, 无法进行区间查找?
什么是区间查找如何查找?

#### Hash
Hash 索引只有精确匹配索引所有列的查询才有效   
对于每一行数据,对所有的索引列计算一个 hashcode.哈希索引将所有的 hashcode 存储在索引中,  
同时在 Hash 表中保存指向每个数据行的指针  
是不是可以理解成 KV 值?  
什么是 Hash 表?  
Hash结构索引的优点:  
索引数据结构紧凑,所以查询速度非常快?  
Hash 索引的数据结构是什么样子的?  

Hash结构索引的缺点:   
Hash索引数据不是按照索引顺序存储的,所以无法用于排序    
Hash索引不支持部分索引匹配查询, 例如数据列(A,B)上创建 Hash 索引,如果查询只有数据列A,无法使用该索引   
Hash索引只支持等值比较查询,不支持任何范围查询, 如 Where price>100;   
Hash索引有可能出现 Hash 冲突,出现 Hash 冲突的时候,必须遍历链表中所有的行指针,逐行比较,直到找到符合条件的行    


#### 索引使用策略:  
不要为所有的列都创建索引  
避免冗余和重复的索引  
尽量拓展索引,不要新建索引??  
频繁作为 Where 过滤条件的列优先考虑索引    

#####独立的列  
如果查询中的列不是独立的列,这数据库不会使用索引  
怎么才算独立的列? 什么不是独立的列?  
独立的列是指索引列不能是表达式的一部分,也不能是函数的参数.  
错误的例子:  

    SELECT actor_id FROM actor WHERE actor_id + 1 = 5;  
    SELECT ... WHERE TO_DAYS(current_date) - TO_DAYS(date_col) <= 10;  

前缀索引和索引的选择性?  
什么是前缀索引?  
前缀索引就是基于原始索引字段，截取前面指定的字符个数或者字节数来做的索引。  
只有字符串或者二进制可以创建前缀索引  
为什么需要前缀索引:  

    你是中国人吗？是的是的是的是的是的是的是的是的是的是的
    确定是中国人？是的是的是的是的是的是的是的是的是的是的

两行数据后面数据一致, 就是前面几个字符不同, 对这样子的数据如何处理?  
1.拿整串数据来做索引  
    方法简单直观,但是会造成索引空间的极大浪费,重复的数据太多,导致索引中无用数据太多,无论是写入还是读取都会产生极大资源消耗  

2.将字符串拆开,做一部分索引  
    把数据前面几个字符和剩余字符分拆为两个字段 r1_prefix ,r1_other,针对字段 r1_prefix 建立索引. 排除掉表结构的变更影响,   
3.把前面 6 个 字符串截取出来的子串做一个索引    
问能否不拆分字段,又能避免掉重复数据的冗余呢?    
于是有了前缀索引    
继续深入可以看这篇文章[前缀索引](https://opensource.actionsky.com/20210120-mysql/#:~:text=%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%A7%8B,%2FBLOB%E3%80%81BINARY%2FVARBINARY%E3%80%82)

有时候需要索引很长的字符列,这会让索引变得大且慢  
##### 解决方法是:可以索引开始的部分字符,这样可以大大减少索引空间,从而提高索引效率.但是也降低了索引的选择性
##### 索引的选择性是指:不重复的索引值和数据表记录的总值数的比值,最大值为1,此时每个记录都有唯一索引与其对应.选择性越高,查询效率越高
对于 BLOB/TEXT/VARCHAR 的列,必须使用前缀索引,因为数据库往往不允许索引这些列的完整长度.
要选择足够长的前缀以保证较高的选择性,又不能太长 为了解决空间
低效例子
    
    SELECT COUNT(*) AS cnt, city FROM sakila.city_demo
    GROUP BY city ORDER BY cnt DESC LIMIT 10;

高效例子:
   
    SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref FROM sakila.city_demo
    GROUP BY city ORDER BY cnt DESC LIMIT 10;

#### 多列索引
什么是多列索引?
一个索引可以定义在表的多个列上.
不要为每个列都创建独立索引
#### 将选择性高地列或者基数大的列优先排在多列多列索引最前列. 需要考虑 Where 子句中的排序 分组 和 范围条件等因素也会影响性能
例如 一张 User 表 包含 name age sex 三个列, 如果将 三个字段组合成多列索引,应该用什么顺序 从选择性高的角度 name>age>sex

##### 聚簇索引
什么是聚簇索引?
聚簇索引不是一种单独的索引类型,是一种索引的存储方式.具体细节依赖于实现方式, 如 innoDB的聚簇索引是在同一个结构中保存了 B树索 引和 数据行
聚簇索引表示数据行和相邻的键值紧凑的存储在了一起,因为数据紧凑,所以访问速度快.因为无法将数据行存放在两个不同的地方, 所以一个表只能有一个聚簇索引
如果没有定义主键, InnoDb会隐式定义一个主键来作为聚簇索引
//可以理解成在单表内存储索引的一个容器, 且一个表只能有一个 用聚簇索引存储的方式

#### 覆盖索引
什么是覆盖索引
覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。
为 A 字段 B字段创建组合索引, select B from table where A="1", 此时B 字段中的值已经包含在了索引中 直接返回 B中的值
索引中包含所需要查询的字段值
使用 Explain 确认覆盖索引是否使用成功
优点有什么?
1. 索引条目通常远小于数据行大小,所以若只读取索引,能大大减少数据访问量
2. 一些存储引擎(例如 MyISAM) 在内存中只缓存索引,而数据则依赖操作系统来缓存. 因此,只访问索引可以不使用系统调用(费时)
3. 对于 InnoDB 引擎,若辅助索引能够覆盖查询,则无需访问主索引.

####使用索引扫描来做排序
Mysql 有两种方式可以生成排序结果: 1.通过排序操作, 2.按照索引顺序扫描
索引最好既满足排序,有用于查找行.这样,就可以使用索引来对结果排序

####**最左前缀匹配原则 
什么是最左前缀匹配原则(https://juejin.cn/post/6844903966690508814)

联合索引的最左匹配原则
联合索引可以看成一个有序队列
如果表拥有一个联合索引, 任何一个索引的最左前缀都会被优化器用于查找列. 比如,  
如果你创建了一个三列的联合索引包含(col1, col2, col3), 你的索引会生效于(col1),  
(col1, col2), 以及(col1, col2, col3)  

如果查询的列不是索引的最左前缀, 那MySQL不会将索引用于执行查询. 假设你有 下列查询语句:  
    
    SELECT * FROM tbl_name WHERE col1=val1;
    SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;

    SELECT * FROM tbl_name WHERE col2=val2;
    SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;

如果索引存在于(col1, col2, col3), 那只有头两个查询语句用到了索引. 第三个和 第四个查询包含索引的列,   
但是不会用索引去执行查询. 因为(col2)和(col2, col3) 不是(col1, col2, col3)的最左前缀    

小结:  
1.如果你创建了一个联合索引,那么这个索引的前缀都会用于查询, (col1,col2,col3) 是这个索引的全部前缀,只有 (col1),(col1,col2) 和 (col1,col2,col3)  
包含这些列的查询会启用索引查询  
2.其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列 也不行. 即上述中的(col2), (col3), (col2, col3) 都不会启用索引去查询.  
注意, (col1, col3)会启用(col1)的索引查询  

列的排列顺序决定了可命中索引的列数  

索引的优化有哪些?

#### 约束
数据库约束 (CONSTRAINT) 有哪些?  
1. NOT NULL 用于控制字段的内容一定不能为空(NULL)  
2. UNIQUE -字段内容不能重复, 一个表允许多个 UNIQUE 约束  
3. PRIMARY KEY -数据库表中对存储数据对象给予唯一和完整表示的数据列或属性组合,它在表中只允许有一个,主键取值不能为空值 NULL  
4. FOREIGN KEY -在一个表中存在的另一个表的主键成为此表的外键.用于预防破坏表之间的连接的动作, 也能防止非法数据插入外键列,因为它必须是它指向那张表中的值之一  
5. CHECK 用于控制字段值的范围  
