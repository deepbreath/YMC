随着架构规模越来越大,多个子系统通过网络通信相互协作配合完成各个功能,  
为了保证多系统之间的数据一致行,于是有了分布式事务这个玩意.
@TODO 背概念, 但是也需要理解
问题在于基于不稳定的网络环境,建立稳定的分布式应用.
参考:(https://iswade.github.io/translate/distsys/#paxos)

分布式事务有两个理论
1.CAP理论
什么是CAP理论?

2.BASE理论
什么是BASE理论?

分布式事务的常见解决方案
## 1.2PC (两段提交)---强一致性
[什么是两段提交](https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4)
两段提交的目的是在于保证数据的一致性,
可以理解成: 公司理解成公司项目组组长:  组长接收到了任务, 将任务分发给组员, 组长需要主动询问组员任务是否完成 ?
从 协调者获取到参与者的所有信息, 并将消息发送给参与的节点,此时消息将进入各个节点数据库中的undo和redo事务日志中(此处可以理解成,先获取到信息.)
如果此时存在一个参与者没有回复说,我收到了信息, 则协调者对所有的参与者发送回滚命令, 反之通知所有的参与者可以执行各自的事务信息了

要么全部成功, 要么全部失败

#### 第一阶段:投票
1.协调者向所有的参与者发送事务内容,询问是否可以提交事务,并等待所有参与者回答
2.各参与者执行事务操作,将undo和redo信息记入事务日志中(但不提交事务)
3.如果参与者执行成功,返回协调者yes,即可提交,如果执行失败,反馈给协调者no,则不可提交事务

#### 第二阶段: 事务提交 根据 第一阶段反馈信息 和 第二阶段事务执行情况进行处理
如果协调者收到了参与者的失败消息或者超时,直接给每个参与者发送回滚(rollback)消息;  
否则,发送提交发送commit消息,参与者根据协调者的指令提交或者回滚操作,释放所有事务处理过程中使用的锁资源.
(必须在最后阶段释放锁资源) 
事务提交会产生两种状态
1. 当所有的参与者都反馈 YES, 协调者提交事务所有参与者事务全部Commit成功
   1.协调者正式向所有的参与者发出正式提交事务的请求(即 Commit请求)
   2.参与者执行Commit事务,并释放整个事务期间的锁资源
   3.参与者向协调者反馈 Ack 应答完成  
   4.协调者收到所有的参与者 Ack 成功消息后,即完成事务提交

2. 提交事务存在参与者超时或者失败
   1.协调者发起对所有的参与者发起 RollBack 请求
   2.参与者使用阶段一中的undo信息执行回滚操作,并释放整个事务期间占用的资源
   3.各个参与者向协调者反馈Ack完成消息
   4.协调者接收到所有的参与者的Ack后,即完成事务中断
产生的问题
   1.性能问题  
   2.可靠性问题
   3.数据一致性问题

### 2.3PC(三段提交)
什么是三段提交
三段提交是二段提交协议的改进版, 区别在于[三段提交同时在协调者和参与者中都引入超时机制]
三段提交将二段提交的准备阶段拆分为两个阶段.  

#### 第一阶段:预询盘

#### 第二阶段:预提交

#### 第三阶段:事务提交

##3.TCC(Try-Confirm-Cancel)事务---最终一致性(Try的次数?)
可以理解成打一个数据提交的提前量.  
什么是TCC  
TCC是服务化的二阶段编程模型(可以理解成 2pc 二阶提交的拓展),其中 Try, Confirm ,Cancel  均由业务编码完成  
TCC 和 二阶段提交的区别:  
一个是属于应用层面的编码模型. 2PC 是一种算法协议.   
一个是思想 一个是具体实现  

在服务与服务之间做 2PC,  
而不是 而不是服务与数据库之间,每个服务有只有一个连接的数据库集群    
TCC 事务的 Try, Confirm, Cancel 可以理解成 SQL 事务中的 Lock, Commit, Rollback.    

Try 执行业务的时候,需要将执行的数据进行进行锁定.  Confirm, Cancel 都是围绕着 Try 操作进行的 (对数据进行预留操作) 

Confirm: 当Try 阶段服务全部正常执行,执行确认业务逻辑操作  
 
   Confirm/Cancel 根据 Try 操作是否全部执行正常,来判断决定是否执行 Confirm 或者 Cancel. Confirm和Cancel满足幂等性,  
   如果执行失败,将会不断重试直到执行执行成功.  
   执行的资源一定是 Try 阶段就要进行锁定,如果 Try 阶段资源可以正常锁定,则 Confirm 一定能够完整正确提交.Confirm 阶段也可以看成Try的一个补充.  
   Try+Confirm一起组成了一个完整的业务逻辑  

Cancel:当 Try 阶段存在服务执行失败,进入 Cancel 阶段.  
   Cancel取消执行,并释放 Try 锁定的业务资源数据.  
相比较 传统 (X/OPEN XA) 事务机制有以下优点  
什么是(X/OPEN XA)?  
优点:  
   性能提升,控制资源的颗粒度变小,不会锁定整个资源  
   数据最终一致,基于 Confirm 和 Cancel 的幂等性.保证事务最终完成确认或者被取消,保证数据一致性  
   可靠性解决XA协议的协调者单点故障问题,由主业务发起并控制整个业务活动,业务活动管理器也可以变成多点,引入集群  
缺点:
   和系统的的耦合性太高,需要按照具体业务进行编码实现,提高了开发成本

## 4.本地消息表-----最终一致性
在事务主动发起方,新建额外的事务消息表,事务的发起方处理业务和记录事务消息在本地事务中完成,

轮询事务消息表的数据发送事务消息,事务被动方基于消息中间件消费  

可以解决 '业务处理成功'+ 事务消息发送失败 或者 '业务处理失败' + "事务消息成功"

最先开始事物的成为事务主动方,在事务主动方之后处理的 业务方成为事务的被动方.

### 处理步骤:
   第一步:事务的主动方,执行本地数据库事务.  
   第二步:事务主动方,将事务信息发送到消息中间件,通知事务被动发处理事务消息
   第三步:事务被动方通过 消息中间件, 通知事务主动方事务已经处理

### 比喻:  
   陈师傅的连锁快餐店有一份霸王餐黑名单, 提供自己名下各个连锁店铺使用, 减少门店的经济损失.   

   有一天 陈师傅的 A 门店 发现一个名叫张三的人经常来他们门店吃霸王餐 , A 门店通过微信通讯录通知 其他门店警惕张三霸王餐.

#### 此处 A 门店有几种种可能性 (事务主动方):  
1. A 门店先抓到张三,并记录张三图片信息在本地黑名单中, 
    在将消息记录到,手机备忘录中以便复制粘贴告诉别的门店(记录消息表数据)
    复制张三的信息 并通过 (微信通讯录,) 发送微信信息一个个去告诉大家有这一号人,需要大家提高警惕.

2. 抓住了张三但是打印机坏了: (本地业务逻辑出现问题 回滚) 
   A 门店没办法记录张三的信息, 于是放了他, 当作什么都没发生 

3. 抓住了张三记录打印了信息,发送微信信息的时候失败了
   A 门店隔断时间再发送消息给其他门店的成员

4. 被张三给跑了:  (事务主动方,业务失败)
   A 门店就当什么事情都没又发生.

#### 各个门店 收到 A 门店并回复的几种可能性 (事务被动方)
1. 大家收到了张三的信息 并进行记录打印,回复 A 门店我们这边已经记录完了. (事务全部成功)

2. 有个别同事没有回复收到消息,可能去忙别的事情了,消息已经发送了过去. 忙完回来就能看到.

3. 一个门店同事反馈说店里打印机坏了,么办法记录, 则 A 点需要通知之前的门店删除掉原来的记录,放过张三

此处: 微信通讯录可以理解成: 本地事务消息表
     黑名单:存放消息的消息表  
### 优点:  
   从应用业务中实现消息数据的可靠性,减少对中间件的依赖  
   实现起来简单,轻量  

### 缺点:  
   耦合性强,不可公用  
   业务系统使用关系数据库的情况下,消息服务的性能会受到关系数据库的影响  


## 5.MQ事务---最终一致性
MQ事务是对本地消息表事的封装
区别是 MQ事务先写入Half消息至 消息中间件中. 本地消息是先写入本地数据库,而后将消息放入消息中间件,通知事务被动方

跟本地事务消息的区别在于
1. 先写入 Half 消息到MQServer(增加吞吐量)
2. MQServer 返回,我们已将将消息持久化了,你可以写入数据库了
3. 业务写入成功后,返回 MQServer 我写成功(commit)/或者失败了(RollBack)
4. MQServer 收到 Commit 或者 RollBack后 对 Half 状态的消息进行修改,Commit 状态 通知订阅方消息消息, RollBack 则删除这个 Half 消息  

异常在于:
如果 长时间没有收到事务主动方的  Commit 或者 RollBack,  
MQServer 会进行数据回查, 事务主动方会检查 消息本地事物最终执行结果.  
事务主动方会再次返回 事务状态 进行二次确认.  
MQServer 根据返回的 Commit/RollBack 对消息进行投递还是删除      

#### 优点:
   消息数据独立存储,降低系统之间的耦合性  
   提高消息吞吐量  
#### 缺点:
   一次消费发送需要两次网络请求(Half+Commit/RollBack)  
   业务处理服务需要实现消息状态的回查接口  

## 6.Saga事务--最终一致性
将长事务拆分为多个本地短事务
有种责任链的感觉
长线性任务,拆分为多个段

## 适用总结

各种方案的使用场景
参考资料(https://juejin.cn/post/6844903734753886216#heading-24)

## 共识算法  
### Paxos  

### ZAB  
ZAB 是 Zookeeper 原子广播协议
于Paxos 有什么区别:

### Humming共识  
用于管理分布式系统重新配置元数据存储

### ViewStamped Replication  
作为复制协议提供,但也是共识算法  
事务处理加视图变更算法  
保证多数达成的值可以将继续生存  
我们不知道任何生产系统,但我们不确定它们与Paxos一起以某种方式影响了Raft  

### Raft  
Raft 是一种为了管理复制日志的一致性算法。
解决了什么问题:
一致性算法允许一组机器能够像一个整体一样工作
Paxos 和 Raft 相比较:
Raft 更注重的不仅仅是能供工作, 还有能有理解直到为什么能工作运行.

Raft 菜谱有几个组成部分
领导人的选举
日志复制
安全性

每个 Raft 的参与者(节点) 都有三个角色中的一个
有三个角色:
1.候选者
2.领导者
3.跟随着

[Raft](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)
参考资料:
(阿里帮助中心)[https://help.aliyun.com/document_detail/132897.html]  

